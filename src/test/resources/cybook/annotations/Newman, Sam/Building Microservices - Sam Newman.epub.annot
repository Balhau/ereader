<?xml version="1.0"?><annotationSet xmlns="http://ns.adobe.com/digitaleditions/annotations" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:dc="http://purl.org/dc/elements/1.1/"><publication></publication><annotation color="#EE00EE"><dc:date>2016-04-12T05:48:33Z</dc:date><dc:title>2016-04-12T05:48:33Z</dc:title><target><fragment start="text/part0003_split_016.html#point(/1/4/2/2/2/1/4/2:529)" end="text/part0003_split_016.html#point(/1/4/2/2/2/1/5:0)"><text>You’ll also need to think differently about how you scale your systems and ensure that they are resilient. Don’t also be surprised if things like distributed transactions or CAP theorem start giving you headaches, either!</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T05:56:52Z</dc:date><dc:title>2016-04-12T05:56:52Z</dc:title><target><fragment start="text/part0004_split_002.html#point(/1/4/2/2/2/1/6/1:262)" end="text/part0004_split_002.html#point(/1/4/2/2/2/1/6/1:405)"><text>Erik Doernenburg first shared with me the idea that we should think of our role more as town planners than architects for the built environment</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T05:59:00Z</dc:date><dc:title>2016-04-12T05:59:00Z</dc:title><target><fragment start="text/part0004_split_002.html#point(/1/4/2/2/2/1/10/2:609)" end="text/part0004_split_002.html#point(/1/4/2/2/2/1/10/4:19)"><text>To borrow a term from Frank Buschmann, architects have a duty to ensure that the system is habitable for developers too</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T05:59:56Z</dc:date><dc:title>2016-04-12T05:59:56Z</dc:title><target><fragment start="text/part0004_split_002.html#point(/1/4/2/2/2/1/13:2)" end="text/part0004_split_002.html#point(/1/4/2/2/2/1/14/1:167)"><text>So our architects as town planners need to set direction in broad strokes, and only get involved in being highly specific about implementation detail in limited cases.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T06:04:21Z</dc:date><dc:title>2016-04-12T06:04:21Z</dc:title><target><fragment start="text/part0004_split_004.html#point(/1/4/2/2/2/1/5:2)" end="text/part0004_split_004.html#point(/1/4/2/2/2/1/6/3:124)"><text>Making decisions in system design is all about trade-offs, and microservice architectures give us lots of trade-offs to make</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T07:03:20Z</dc:date><dc:title>2016-04-12T07:03:20Z</dc:title><target><fragment start="text/part0004_split_016.html#point(/1/4/2/2/2/2/2/1/15:1)" end="text/part0004_split_016.html#point(/1/4/2/2/2/2/2/1/16/1:114)"><text>
 I have also seen many a team’s morale and productivity destroyed by having a mandated framework thrust upon them</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T07:07:37Z</dc:date><dc:title>2016-04-12T07:07:37Z</dc:title><target><fragment start="text/part0004_split_018.html#point(/1/4/2/2/2/1/6/1:665)" end="text/part0004_split_018.html#point(/1/4/2/2/2/1/7:0)"><text> If you are working in an organization that places lots of restrictions on how developers can do their work, then microservices may not be for you.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T07:18:16Z</dc:date><dc:title>2016-04-12T07:18:16Z</dc:title><target><fragment start="text/part0004_split_020.html#point(/1/4/2/2/2/1/4/3:240)" end="text/part0004_split_020.html#point(/1/4/2/2/2/1/5:0)"><text>Much of the role of the technical leader is about helping grow them — to help them understand the vision themselves — and also ensuring that they can be active participants in shaping and implementing the vision too.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T07:19:10Z</dc:date><dc:title>2016-04-12T07:19:10Z</dc:title><target><fragment start="text/part0004_split_020.html#point(/1/4/2/2/2/1/8/1:1)" end="text/part0004_split_020.html#point(/1/4/2/2/2/1/8/1:66)"><text> am a strong believer that great software comes from great people</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T07:49:56Z</dc:date><dc:title>2016-04-12T07:49:56Z</dc:title><target><fragment start="text/part0005_split_003.html#point(/1/4/2/2/2/2/2/1/7:2)" end="text/part0005_split_003.html#point(/1/4/2/2/2/2/2/1/9:0)"><text>A loosely coupled service knows as little as it needs to about the services with which it collaborates. This also means we probably want to limit the number of different types of calls from one service to another, because beyond the potential performance problem, chatty communication can lead to tight coupling.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T14:24:44Z</dc:date><dc:title>2016-04-12T14:24:44Z</dc:title><target><fragment start="text/part0006_split_000.html#point(/1/4/2/1/3:3)" end="text/part0006_split_000.html#point(/1/4/2/1/5:0)"><text>Getting integration right is the single most important aspect of the technology associated with microservices in my opinion. Do it well, and your microservices retain their autonomy, allowing you to change and release them independent of the whole. Get it wrong, and disaster awaits. Hopefully once you’ve read this chapter you’ll learn how to avoid some of the biggest pitfalls that have plagued other attempts at SOA and could yet await you in your journey to microservices.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T14:33:02Z</dc:date><dc:title>2016-04-12T14:33:02Z</dc:title><target><fragment start="text/part0006_split_007.html#point(/1/4/2/2/2/1/15:2)" end="text/part0006_split_007.html#point(/1/4/2/2/2/1/16/2:163)"><text>Remember when we talked about the core principles behind good microservices? Strong cohesion and loose coupling — with database integration, we lose both things.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T17:22:54Z</dc:date><dc:title>2016-04-12T17:22:54Z</dc:title><target><fragment start="text/part0006_split_017.html#point(/1/4/2/2/2/2/2/1/3:2)" end="text/part0006_split_017.html#point(/1/4/2/2/2/2/2/1/4/5:68)"><text>Another principle introduced in REST that can help us avoid the coupling between client and server is the concept of hypermedia as the engine of application state (often abbreviated as HATEOAS, and boy, did it need an abbreviation</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T17:25:24Z</dc:date><dc:title>2016-04-12T17:25:24Z</dc:title><target><fragment start="text/part0006_split_018.html#point(/1/4/2/2/2/2/2/1/12/3:196)" end="text/part0006_split_018.html#point(/1/4/2/2/2/2/2/1/12/3:353)"><text>I find it odd that people pick JSON because it is nice and lightweight, then try and push concepts into it like hypermedia controls that already exist in XML</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T17:28:38Z</dc:date><dc:title>2016-04-12T17:28:38Z</dc:title><target><fragment start="text/part0006_split_019.html#point(/1/4/2/2/2/2/2/1/6/1:164)" end="text/part0006_split_019.html#point(/1/4/2/2/2/2/2/1/6/1:324)"><text>I saw used effectively by one of our teams was to delay the implementation of proper persistence for the microservice, until the interface had stabilized enough</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-12T17:32:20Z</dc:date><dc:title>2016-04-12T17:32:20Z</dc:title><target><fragment start="text/part0006_split_020.html#point(/1/4/2/2/2/2/2/1/16/1:136)" end="text/part0006_split_020.html#point(/1/4/2/2/2/2/2/1/16/3:64)"><text>I recommend REST in Practice (O’Reilly), which covers the topic of REST over HTTP in depth</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T06:59:22Z</dc:date><dc:title>2016-04-13T06:59:22Z</dc:title><target><fragment start="text/part0006_split_030.html#point(/1/4/2/2/2/2/2/1/5:2)" end="text/part0006_split_030.html#point(/1/4/2/2/2/2/2/1/6/1:160)"><text>Another key to deferring a breaking change is to encourage good behavior in your clients, and avoid them binding too tightly to your services in the first place</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T07:01:00Z</dc:date><dc:title>2016-04-13T07:01:00Z</dc:title><target><fragment start="text/part0006_split_030.html#point(/1/4/2/2/2/2/2/1/12/9:220)" end="text/part0006_split_030.html#point(/1/4/2/2/2/2/2/1/14:0)"><text>This pattern — of implementing a reader able to ignore changes we don’t care about — is what Martin Fowler calls a Tolerant Reader.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T07:01:57Z</dc:date><dc:title>2016-04-13T07:01:57Z</dc:title><target><fragment start="text/part0006_split_030.html#point(/1/4/2/2/2/2/2/1/15:2)" end="text/part0006_split_030.html#point(/1/4/2/2/2/2/2/1/16/7:94)"><text>The example of a client trying to be as flexible as possible in consuming a service demonstrates Postel’s Law (otherwise known as the robustness principle), which states: “Be conservative in what you do, be liberal in what you accept from others.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T08:03:01Z</dc:date><dc:title>2016-04-13T08:03:01Z</dc:title><target><fragment start="text/part0006_split_040.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0006_split_040.html#point(/1/4/2/2/2/2/2/1/12/4:0)"><text>This pattern is sometimes referred to as backends for frontends (BFFs)</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T08:03:41Z</dc:date><dc:title>2016-04-13T08:03:41Z</dc:title><target><fragment start="text/part0006_split_040.html#point(/1/4/2/2/2/2/2/1/13:2)" end="text/part0006_split_040.html#point(/1/4/2/2/2/2/2/1/14/1:104)"><text>The danger with this approach is the same as with any aggregating layer; it can take on logic it shouldn</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T09:01:29Z</dc:date><dc:title>2016-04-13T09:01:29Z</dc:title><target><fragment start="text/part0006_split_046.html#point(/1/4/2/2/2/2/2/1/10/1/4/3:385)" end="text/part0006_split_046.html#point(/1/4/2/2/2/2/2/1/10/1/5:1)"><text>Many implementations of CRM tools I have seen are among the best examples of adhesive (as opposed to cohesive) services.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T09:22:38Z</dc:date><dc:title>2016-04-13T09:22:38Z</dc:title><target><fragment start="text/part0006_split_047.html#point(/1/4/2/2/2/2/2/1/4/5:1)" end="text/part0006_split_047.html#point(/1/4/2/2/2/2/2/1/4/5:143)"><text> Much like with our example of fronting the CMS system with our own code, with a strangler you capture and intercept calls to the old system. </text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T09:23:45Z</dc:date><dc:title>2016-04-13T09:23:45Z</dc:title><target><fragment start="text/part0006_split_048.html#point(/1/4/2/2/2/1/6/2/1:1)" end="text/part0006_split_048.html#point(/1/4/2/2/2/1/6/11:0)"><text>Avoid database integration at all costs.


Understand the trade-offs between REST and RPC, but strongly consider REST as a good starting point for request/response integration.


Prefer choreography over orchestration.


Avoid breaking changes and the need to version by understanding Postel’s Law and using tolerant readers.


Think of user interfaces as compositional layers.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T09:25:41Z</dc:date><dc:title>2016-04-13T09:25:41Z</dc:title><target><fragment start="text/part0007_split_001.html#point(/1/4/2/2/2/1/5:2)" end="text/part0007_split_001.html#point(/1/4/2/2/2/1/6/5:4)"><text>In his book Working Effectively with Legacy Code (Prentice-Hall), Michael Feathers defines the concept of a seam —</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T09:45:42Z</dc:date><dc:title>2016-04-13T09:45:42Z</dc:title><target><fragment start="text/part0007_split_010.html#point(/1/4/2/2/2/1/10/1:431)" end="text/part0007_split_010.html#point(/1/4/2/2/2/1/11:0)"><text> A great place to start is to use a tool like the freely available SchemaSpy, which can generate graphical representations of the relationships between tables.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T10:39:48Z</dc:date><dc:title>2016-04-13T10:39:48Z</dc:title><target><fragment start="text/part0007_split_028.html#point(/1/4/2/2/2/1/8/2:286)" end="text/part0007_split_028.html#point(/1/4/2/2/2/1/8/4:0)"><text>using this approach, which it then open sourced as the Aegisthus project</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T11:51:16Z</dc:date><dc:title>2016-04-13T11:51:16Z</dc:title><target><fragment start="text/part0008_split_005.html#point(/1/4/2/2/2/2/2/1/5:2)" end="text/part0008_split_005.html#point(/1/4/2/2/2/2/2/1/7:1)"><text>During this time of churn, changes across service boundaries are more likely, and what is in or not in a given service is likely to change frequently. During this period, having all services in a single build to reduce the cost of cross-service changes may make sense.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T12:00:51Z</dc:date><dc:title>2016-04-13T12:00:51Z</dc:title><target><fragment start="text/part0008_split_008.html#point(/1/4/2/2/2/1/21:2)" end="text/part0008_split_008.html#point(/1/4/2/2/2/1/22/3:58)"><text>Packer is a tool designed to make creation of images much easier</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T12:02:13Z</dc:date><dc:title>2016-04-13T12:02:13Z</dc:title><target><fragment start="text/part0008_split_009.html#point(/1/4/2/2/2/2/2/1/6/1:296)" end="text/part0008_split_009.html#point(/1/4/2/2/2/2/2/1/6/3:0)"><text> We can focus our efforts, then, on automating the creation and deployment of these images. This also becomes a really neat way to implement another deployment concept, the immutable server</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T12:03:00Z</dc:date><dc:title>2016-04-13T12:03:00Z</dc:title><target><fragment start="text/part0008_split_010.html#point(/1/4/2/2/2/2/2/1/4/4:163)" end="text/part0008_split_010.html#point(/1/4/2/2/2/2/2/1/5:1)"><text> But once we run our deployment process, what happens if someone comes along, logs into the box, and changes things independently of what is in source control? This problem is often called configuration drift — the code in source control no longer reflects the configuration of the running host.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T12:07:13Z</dc:date><dc:title>2016-04-13T12:07:13Z</dc:title><target><fragment start="text/part0008_split_011.html#point(/1/4/2/2/2/1/13:2)" end="text/part0008_split_011.html#point(/1/4/2/2/2/1/15:1)"><text>This balance, between production-like environments and fast feedback, won’t be static. Keep an eye on the bugs you find further downstream and your feedback times, and adjust this balance as required.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T12:27:56Z</dc:date><dc:title>2016-04-13T12:27:56Z</dc:title><target><fragment start="text/part0008_split_017.html#point(/1/4/2/2/2/2/2/1/7:2)" end="text/part0008_split_017.html#point(/1/4/2/2/2/2/2/1/8/1:230)"><text>When PaaS solutions work well, they work very well indeed. However, when they don’t quite work for you, you often don’t have much control in terms of getting under the hood to fix things. This is part of the trade-off you make</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T12:28:07Z</dc:date><dc:title>2016-04-13T12:28:07Z</dc:title><target><fragment start="text/part0008_split_017.html#point(/1/4/2/2/2/2/2/1/8/1:231)" end="text/part0008_split_017.html#point(/1/4/2/2/2/2/2/1/8/1:330)"><text> I would say that in my experience the smarter the PaaS solutions try to be, the more they go wrong</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-13T15:12:53Z</dc:date><dc:title>2016-04-13T15:12:53Z</dc:title><target><fragment start="text/part0008_split_024.html#point(/1/4/2/2/2/2/2/1/2/1:0)" end="text/part0008_split_024.html#point(/1/4/2/2/2/2/2/1/2/1:0)"></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-14T22:27:20Z</dc:date><dc:title>2016-04-14T22:27:20Z</dc:title><target><fragment start="text/part0009_split_007.html#point(/1/4/2/2/2/2/2/1/5:2)" end="text/part0009_split_007.html#point(/1/4/2/2/2/2/2/1/7:1)"><text>I worked on one monolithic system, for example, where we had 4,000 unit tests, 1,000 service tests, and 60 end-to-end tests. We decided that from a feedback point of view we had way too many service and end-to-end tests (the latter of which were the worst offenders in impacting feedback loops), so we worked hard to replace the test coverage with smaller-scoped tests.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-14T22:38:06Z</dc:date><dc:title>2016-04-14T22:38:06Z</dc:title><target><fragment start="text/part0009_split_013.html#point(/1/4/2/2/2/1/5:2)" end="text/part0009_split_013.html#point(/1/4/2/2/2/1/6/3:98)"><text>The more moving parts, the more brittle our tests may be, and the less deterministic they are. If you have tests that sometimes fail, but everyone just re-runs them because they may pass again later, then you have flaky tests</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-14T22:53:46Z</dc:date><dc:title>2016-04-14T22:53:46Z</dc:title><target><fragment start="text/part0009_split_018.html#point(/1/4/2/2/2/1/5:2)" end="text/part0009_split_018.html#point(/1/4/2/2/2/1/6/1:301)"><text>This situation worsens if we fall into the trap of adding a new end-to-end test for every piece of functionality we add. Show me a codebase where every new story results in a new end-to-end test, and I’ll show you a bloated test suite that has poor feedback cycles and huge overlaps in test coverage</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-14T22:57:46Z</dc:date><dc:title>2016-04-14T22:57:46Z</dc:title><target><fragment start="text/part0009_split_020.html#point(/1/4/2/2/2/2/2/1/4/3:171)" end="text/part0009_split_020.html#point(/1/4/2/2/2/2/2/1/4/3:233)"><text>Originally just for Ruby, Pact now includes JVM and .NET ports</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-16T21:10:13Z</dc:date><dc:title>2016-04-16T21:10:13Z</dc:title><target><fragment start="text/part0009_split_025.html#point(/1/4/2/2/2/2/2/1/10/1:540)" end="text/part0009_split_025.html#point(/1/4/2/2/2/2/2/1/11:0)"><text>The work to shadow production traffic can be complex, though, especially if the events/requests being replayed aren’t idempotent.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-16T21:33:50Z</dc:date><dc:title>2016-04-16T21:33:50Z</dc:title><target><fragment start="text/part0009_split_027.html#point(/1/4/2/2/2/1/5:2)" end="text/part0009_split_027.html#point(/1/4/2/2/2/1/6/5:32)"><text>The term nonfunctional never sat well with me. Some of the things that get covered by this term seem very functional in nature! One of my colleagues, Sarah Taraporewalla, coined the phrase cross-functional requirements (CFR) instead, which I greatly prefer</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-16T21:36:18Z</dc:date><dc:title>2016-04-16T21:36:18Z</dc:title><target><fragment start="text/part0009_split_027.html#point(/1/4/2/2/2/1/13:2)" end="text/part0009_split_027.html#point(/1/4/2/2/2/1/15:1)"><text>All too often, considerations about CFRs come far too late. I strongly suggest looking at your CFRs as early as possible, and reviewing them regularly.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-16T21:40:46Z</dc:date><dc:title>2016-04-16T21:40:46Z</dc:title><target><fragment start="text/part0009_split_029.html#point(/1/4/2/2/2/1/7:2)" end="text/part0009_split_029.html#point(/1/4/2/2/2/1/9:1)"><text>If you are interested in reading more about testing, I recommend Agile Testing by Lisa Crispin and Janet Gregory (Addison-Wesley), which among other things covers the use of the testing quadrant in more detail.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-16T21:56:36Z</dc:date><dc:title>2016-04-16T21:56:36Z</dc:title><target><fragment start="text/part0010_split_006.html#point(/1/4/2/2/2/1/13:2)" end="text/part0010_split_006.html#point(/1/4/2/2/2/1/14/5:40)"><text>Libraries exist for a number of different platforms that allow our services to send metrics to standard systems. Codahale’s Metrics library is one such example library for the JVM</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:32:32Z</dc:date><dc:title>2016-04-17T07:32:32Z</dc:title><target><fragment start="text/part0010_split_010.html#point(/1/4/2/2/2/1/8/3:194)" end="text/part0010_split_010.html#point(/1/4/2/2/2/1/8/3:234)"><text>Some of these libraries, such as Hystrix</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:37:35Z</dc:date><dc:title>2016-04-17T07:37:35Z</dc:title><target><fragment start="text/part0010_split_013.html#point(/1/4/2/2/2/1/6/1:295)" end="text/part0010_split_013.html#point(/1/4/2/2/2/1/6/3:94)"><text> Teams now measure themselves not in terms of how many points they complete, but instead optimize for how long it takes for code to get from laptop to live</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:38:07Z</dc:date><dc:title>2016-04-17T07:38:07Z</dc:title><target><fragment start="text/part0010_split_013.html#point(/1/4/2/2/2/1/9:2)" end="text/part0010_split_013.html#point(/1/4/2/2/2/1/10/4:122)"><text>Riemann is an event server that allows for fairly advanced aggregation and routing of events and can form part of such a solution</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:38:29Z</dc:date><dc:title>2016-04-17T07:38:29Z</dc:title><target><fragment start="text/part0010_split_013.html#point(/1/4/2/2/2/1/10/4:124)" end="text/part0010_split_013.html#point(/1/4/2/2/2/1/10/8:159)"><text>Suro is Netflix’s data pipeline and operates in a similar space. Suro is explicitly used to handle both metrics associated with user behavior, and more operational data like application logs</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:41:04Z</dc:date><dc:title>2016-04-17T07:41:04Z</dc:title><target><fragment start="text/part0010_split_014.html#point(/1/4/2/2/2/1/14/1:462)" end="text/part0010_split_014.html#point(/1/4/2/2/2/1/15:1)"><text>in my earlier publication Lightweight Systems for Realtime Monitoring (O’Reilly).
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:46:42Z</dc:date><dc:title>2016-04-17T07:46:42Z</dc:title><target><fragment start="text/part0011_split_002.html#point(/1/4/2/2/2/2/2/1/10/1:742)" end="text/part0011_split_002.html#point(/1/4/2/2/2/2/2/1/10/1:938)"><text>At the time of writing, OpenAM and Gluu are two of the very few options available in this space, compared to a wealth of options for SAML (including Active Directory, which seems to be everywhere)</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:48:30Z</dc:date><dc:title>2016-04-17T07:48:30Z</dc:title><target><fragment start="text/part0011_split_003.html#point(/1/4/2/2/2/2/2/1/10/1:161)" end="text/part0011_split_003.html#point(/1/4/2/2/2/2/2/1/11:1)"><text>If you’re using HTTP, it could populate headers with this information. Shibboleth is one tool that can do this for you, and I’ve seen it used with Apache to great effect to handle integration with SAML-based identity providers.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T07:50:34Z</dc:date><dc:title>2016-04-17T07:50:34Z</dc:title><target><fragment start="text/part0011_split_003.html#point(/1/4/2/2/2/2/2/1/16/1:242)" end="text/part0011_split_003.html#point(/1/4/2/2/2/2/2/1/16/1:428)"><text>Gateway layers tend to take on more and more functionality, which itself can end up being a giant coupling point. And the more functionality something has, the greater the attack surface</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:08:05Z</dc:date><dc:title>2016-04-17T08:08:05Z</dc:title><target><fragment start="text/part0011_split_012.html#point(/1/4/2/2/2/2/2/1/15:2)" end="text/part0011_split_012.html#point(/1/4/2/2/2/2/2/1/16/1:120)"><text>This problem, unfortunately, has no simple answer, because it isn’t a simple problem. Be aware that it exists, though.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:21:52Z</dc:date><dc:title>2016-04-17T08:21:52Z</dc:title><target><fragment start="text/part0011_split_025.html#point(/1/4/2/2/2/1/22/2:25)" end="text/part0011_split_025.html#point(/1/4/2/2/2/1/22/2:168)"><text> As you can see, the choices we made about what technology to use were based on an understanding of the nature of the information being secured</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:26:25Z</dc:date><dc:title>2016-04-17T08:26:25Z</dc:title><target><fragment start="text/part0011_split_029.html#point(/1/4/2/2/2/1/5:2)" end="text/part0011_split_029.html#point(/1/4/2/2/2/1/6/4:267)"><text>There are automated tools that can probe our systems for vulnerabilities, such as by looking for cross-site scripting attacks. The Zed Attack Proxy (aka ZAP) is a good example. Informed by the work of OWASP, ZAP attempts to re-create malicious attacks on your website</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:29:58Z</dc:date><dc:title>2016-04-17T08:29:58Z</dc:title><target><fragment start="text/part0012_split_000.html#point(/1/4/2/1/4/3:174)" end="text/part0012_split_000.html#point(/1/4/2/1/5:1)"><text>As we’ll learn in this chapter, you ignore your company’s organization chart at your peril!
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:30:36Z</dc:date><dc:title>2016-04-17T08:30:36Z</dc:title><target><fragment start="text/part0012_split_000.html#point(/1/4/2/1/7:1)" end="text/part0012_split_000.html#point(/1/4/2/1/8/6:25)"><text>
 Melvin Conway’s paper How Do Committees Invent, published in Datamation magazine in April 1968, </text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:31:03Z</dc:date><dc:title>2016-04-17T08:31:03Z</dc:title><target><fragment start="text/part0012_split_000.html#point(/1/4/2/1/10/1:1)" end="text/part0012_split_000.html#point(/1/4/2/1/11:0)"><text>Any organization that designs a system (defined more broadly here than just information systems) will inevitably produce a design whose structure is a copy of the organization’s communication structure.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:31:23Z</dc:date><dc:title>2016-04-17T08:31:23Z</dc:title><target><fragment start="text/part0012_split_000.html#point(/1/4/2/1/12/3:27)" end="text/part0012_split_000.html#point(/1/4/2/1/12/3:104)"><text>If you have four groups working on a compiler, you’ll get a 4-pass compiler</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T08:32:43Z</dc:date><dc:title>2016-04-17T08:32:43Z</dc:title><target><fragment start="text/part0012_split_002.html#point(/1/4/2/2/2/2/2/1/5:2)" end="text/part0012_split_002.html#point(/1/4/2/2/2/2/3:0)"><text>In their study, in which they matched similar product pairs from each type of organization, the authors found that the more loosely coupled organizations actually created more modular, less coupled systems, whereas the more tightly focused organization’s software was less modularized.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T09:02:07Z</dc:date><dc:title>2016-04-17T09:02:07Z</dc:title><target><fragment start="text/part0012_split_004.html#point(/1/4/2/2/2/1/4/1:124)" end="text/part0012_split_004.html#point(/1/4/2/2/2/1/4/1:239)"><text>Early on, Amazon started to understand the benefits of teams owning the whole lifecycle of the systems they managed</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T09:10:05Z</dc:date><dc:title>2016-04-17T09:10:05Z</dc:title><target><fragment start="text/part0012_split_007.html#point(/1/4/2/2/2/1/5:2)" end="text/part0012_split_007.html#point(/1/4/2/2/2/1/6/1:193)"><text>This model is certainly one I favor. It pushes the decisions to the people best able to make them, giving the team both increased power and autonomy, but also making it accountable for its work</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T11:24:11Z</dc:date><dc:title>2016-04-17T11:24:11Z</dc:title><target><fragment start="text/part0012_split_021.html#point(/1/4/2/2/2/1/3:2)" end="text/part0012_split_021.html#point(/1/4/2/2/2/1/4/3:265)"><text>Conway’s law highlights the perils of trying to enforce a system design that doesn’t match the organization. This leads us to trying to align service ownership to colocated teams, which themselves are aligned around the same bounded contexts of the organization</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T11:51:08Z</dc:date><dc:title>2016-04-17T11:51:08Z</dc:title><target><fragment start="text/part0013_split_004.html#point(/1/4/2/2/2/1/18/1:180)" end="text/part0013_split_004.html#point(/1/4/2/2/2/1/18/3:93)"><text>When you get down to it, we discovered the hard way that systems that just act slow are much harder to deal with than systems that just fail fast. In a distributed system, latency kills</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T11:51:55Z</dc:date><dc:title>2016-04-17T11:51:55Z</dc:title><target><fragment start="text/part0013_split_005.html#point(/1/4/2/2/2/1/3:2)" end="text/part0013_split_005.html#point(/1/4/2/2/2/1/4/5:96)"><text>In his book Antifragile (Random House), Nassim Taleb talks about things that actually benefit from failure and disorder</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T11:54:35Z</dc:date><dc:title>2016-04-17T11:54:35Z</dc:title><target><fragment start="text/part0013_split_005.html#point(/1/4/2/2/2/1/11:1)" end="text/part0013_split_005.html#point(/1/4/2/2/2/1/12/1:261)"><text>
 Embracing and inciting failure through software, and building systems that can handle it, is only part of what Netflix does. It also understands the importance of learning from the failure when it occurs, and adopting a blameless culture when mistakes do happen</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T11:57:43Z</dc:date><dc:title>2016-04-17T11:57:43Z</dc:title><target><fragment start="text/part0013_split_007.html#point(/1/4/2/2/2/2/2/1/4/3:328)" end="text/part0013_split_007.html#point(/1/4/2/2/2/2/2/1/5:1)"><text> Michael Nygard’s book Release It! (Pragmatic Programmers) shows how the same idea can work wonders as a protection mechanism for our software.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:02:50Z</dc:date><dc:title>2016-04-17T12:02:50Z</dc:title><target><fragment start="text/part0013_split_008.html#point(/1/4/2/2/2/2/2/1/16/3:241)" end="text/part0013_split_008.html#point(/1/4/2/2/2/2/2/1/16/5:0)"><text> Hystrix allows you, for example, to implement bulkheads that actually reject requests in certain conditions to ensure that resources don’t become even more saturated; this is known as load shedding</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:20:25Z</dc:date><dc:title>2016-04-17T12:20:25Z</dc:title><target><fragment start="text/part0013_split_017.html#point(/1/4/2/2/2/2/2/1/10/1:166)" end="text/part0013_split_017.html#point(/1/4/2/2/2/2/2/1/10/1:313)"><text>This can be disastrous. At the start of a new project, we often don’t know exactly what we want to build, nor do we know if it will be successful</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:23:29Z</dc:date><dc:title>2016-04-17T12:23:29Z</dc:title><target><fragment start="text/part0013_split_020.html#point(/1/4/2/2/2/2/2/1/6/6:94)" end="text/part0013_split_020.html#point(/1/4/2/2/2/2/2/1/6/8:108)"><text>Such a setup is called eventually consistent, and if you can handle the temporary inconsistency it is a fairly easy and common way to help scale systems</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:29:15Z</dc:date><dc:title>2016-04-17T12:29:15Z</dc:title><target><fragment start="text/part0013_split_023.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0013_split_023.html#point(/1/4/2/2/2/2/3:0)"><text>Be warned, however: this sort of pattern is quite a shift away from a model where a single data store handles all our CRUD operations. I’ve seen more than one experienced development team struggle to get this pattern right!
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:29:30Z</dc:date><dc:title>2016-04-17T12:29:30Z</dc:title><target><fragment start="text/part0013_split_023.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0013_split_023.html#point(/1/4/2/2/2/2/2/1/12/1:224)"><text>Be warned, however: this sort of pattern is quite a shift away from a model where a single data store handles all our CRUD operations. I’ve seen more than one experienced development team struggle to get this pattern right</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:32:49Z</dc:date><dc:title>2016-04-17T12:32:49Z</dc:title><target><fragment start="text/part0013_split_025.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0013_split_025.html#point(/1/4/2/2/2/2/3:0)"><text>For every public-facing website I’ve worked on, we’ve ended up doing a mix of all three approaches. But for more than one distributed system, I’ve gotten away with no caching at all. But it all comes down to knowing what load you need to handle, how fresh your data needs to be, and what your system can do right now. Knowing that you have a number of different tools at your disposal is just the beginning.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:33:51Z</dc:date><dc:title>2016-04-17T12:33:51Z</dc:title><target><fragment start="text/part0013_split_025.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0013_split_025.html#point(/1/4/2/2/2/2/2/1/12/1:412)"><text>For every public-facing website I’ve worked on, we’ve ended up doing a mix of all three approaches. But for more than one distributed system, I’ve gotten away with no caching at all. But it all comes down to knowing what load you need to handle, how fresh your data needs to be, and what your system can do right now. Knowing that you have a number of different tools at your disposal is just the beginning</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:38:41Z</dc:date><dc:title>2016-04-17T12:38:41Z</dc:title><target><fragment start="text/part0013_split_026.html#point(/1/4/2/2/2/2/2/1/14/5:128)" end="text/part0013_split_026.html#point(/1/4/2/2/2/2/2/1/15:1)"><text>For a more in-depth discussion of the various merits, take a look at the book REST In Practice (O’Reilly) or read section 13 of the HTTP 1.1 specification, which describes how both clients and servers are supposed to implement these various controls.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:40:49Z</dc:date><dc:title>2016-04-17T12:40:49Z</dc:title><target><fragment start="text/part0013_split_028.html#point(/1/4/2/2/2/2/2/1/5:1)" end="text/part0013_split_028.html#point(/1/4/2/2/2/2/2/1/6/5:283)"><text>
 A technique I saw used at the Guardian, and subsequently elsewhere, was to crawl the existing live site periodically to generate a static version of the website that could be served in the event of an outage. Although this crawled version wasn’t as fresh as the cached content served from the live system, in a pinch it could ensure that a version of the site would get displayed</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T12:45:14Z</dc:date><dc:title>2016-04-17T12:45:14Z</dc:title><target><fragment start="text/part0013_split_030.html#point(/1/4/2/2/2/2/2/1/3:2)" end="text/part0013_split_030.html#point(/1/4/2/2/2/2/2/1/5:0)"><text>Be careful about caching in too many places! The more caches between you and the source of fresh data, the more stale the data can be, and the harder it can be to determine the freshness of the data that a client eventually sees. This can be especially problematic with a microservice architecture where you have multiple services involved in a call chain. Again, the more caching you have, the harder it will be to assess the freshness of any piece of data. So if you think a cache is a good idea, keep it simple, stick to one, and think carefully before adding more!</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T13:07:47Z</dc:date><dc:title>2016-04-17T13:07:47Z</dc:title><target><fragment start="text/part0013_split_031.html#point(/1/4/2/2/2/2/2/1/13:2)" end="text/part0013_split_031.html#point(/1/4/2/2/2/2/2/1/14/1:187)"><text>Caching can be very powerful indeed, but you need to understand the full path of data that is cached from source to destination to really appreciate its complexities and what can go wrong</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T15:55:24Z</dc:date><dc:title>2016-04-17T15:55:24Z</dc:title><target><fragment start="text/part0013_split_037.html#point(/1/4/2/2/2/2/2/1/3:2)" end="text/part0013_split_037.html#point(/1/4/2/2/2/2/2/1/4/5:65)"><text>Which is right, AP or CP? Well, the reality is it depends. As the people building the system, we know the trade-off exists</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T15:59:40Z</dc:date><dc:title>2016-04-17T15:59:40Z</dc:title><target><fragment start="text/part0013_split_038.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0013_split_038.html#point(/1/4/2/2/2/2/3:0)"><text>You’ll often see posts about people beating the CAP theorem. They haven’t. What they have done is create a system where some capabilities are CP, and some are AP. The mathematical proof behind the CAP theorem holds. Despite many attempts at school, I’ve learned that you don’t beat math.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T15:59:57Z</dc:date><dc:title>2016-04-17T15:59:57Z</dc:title><target><fragment start="text/part0013_split_038.html#point(/1/4/2/2/2/2/2/1/11:2)" end="text/part0013_split_038.html#point(/1/4/2/2/2/2/2/1/12/3:249)"><text>You’ll often see posts about people beating the CAP theorem. They haven’t. What they have done is create a system where some capabilities are CP, and some are AP. The mathematical proof behind the CAP theorem holds. Despite many attempts at school, I’ve learned that you don’t beat math</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T16:08:54Z</dc:date><dc:title>2016-04-17T16:08:54Z</dc:title><target><fragment start="text/part0013_split_043.html#point(/1/4/2/2/2/2/2/1/9:2)" end="text/part0013_split_043.html#point(/1/4/2/2/2/2/2/1/11:0)"><text>Zookeeper itself is fairly generic in what it offers, which is why it is used for so many use cases. You can think of it just as a replicated tree of information that you can be alerted about when it changes. This means that you’ll typically build things on top of it to suit your particular use case. Luckily, client libraries exist for most languages out there.</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T16:18:18Z</dc:date><dc:title>2016-04-17T16:18:18Z</dc:title><target><fragment start="text/part0013_split_048.html#point(/1/4/2/2/2/1/4/3:593)" end="text/part0013_split_048.html#point(/1/4/2/2/2/1/5:1)"><text>Two different pieces of technology, Swagger and HAL, try to make this a reality, and both are worth looking at.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T16:28:36Z</dc:date><dc:title>2016-04-17T16:28:36Z</dc:title><target><fragment start="text/part0014_split_004.html#point(/1/4/2/2/2/2/2/1/4/3:106)" end="text/part0014_split_004.html#point(/1/4/2/2/2/2/2/1/5:1)"><text>Services should also hide their databases to avoid falling into one of the most common sorts of coupling that can appear in traditional service-oriented architectures, and use data pumps or event data pumps to consolidate data across multiple services for reporting purposes.
</text></fragment></target><content><text></text></content></annotation><annotation color="#EE00EE"><dc:date>2016-04-17T16:39:27Z</dc:date><dc:title>2016-04-17T16:39:27Z</dc:title><target><fragment start="text/part0014_split_009.html#point(/1/4/2/2/2/1/3:2)" end="text/part0014_split_009.html#point(/1/4/2/2/2/1/5:1)"><text>I get asked this question a lot. My first piece of advice would be that the less well you understand a domain, the harder it will be for you to find proper bounded contexts for your services. As we discussed previously, getting service boundaries wrong can result in having to make lots of changes in service-to-service collaboration — an expensive operation. So if you’re coming to a monolithic system for which you don’t understand the domain, spend some time learning what the system does first, and then look to identify clean module boundaries prior to splitting out services.
</text></fragment></target><content><text></text></content></annotation></annotationSet>